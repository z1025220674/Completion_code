# Completion_code
# 伪随机正交预编码矩阵



# 0 顶层





## 1 混沌序列生成单元

![image-20221124130731633](./image-公式1)

​												$$\huge x_{k+1}=x_{k}(2^{16}-x_k)*2^{-30}     $$        **(1-1)**

**功能介绍**

1. 实现生成随机性参数
2. 生成的随机参数用于扰乱伪随机正交预编码矩阵的星座点排布和提高随机性
3. 本模块主体功能：输入初始值，固定迭代次数，固定有效位参数，固定扩大倍数；
   1. 以$x_{0}$为初值
   2. 根据式子（1-1）运算并放入寄存器；根据设置的扩大倍数，公式缩放会丢失一些精度；
   3. 运算后的值$x_{1}$，再次重复2步骤，同时一个新的寄存器用于存储硬判决后的$x_{1}$
   4. 迭代次数完成，输出用于存储硬判决后的$x_{1}$ 

**输入参数**

1. $x_0$初始值（使用标准握手信号）

   + vld：代表初始值是有效的，本信号的拉高是自由控制，拉低是handshake后拉低
   + rdy：拉低条件：收到hanshake；拉高条件：1.初始化，2.完成迭代

2. 迭代次数（param参数=200）

3. 输出有效位数（param参数=16），1bit就是一个$x_n$

**功能实现**

+ 实现公式，根据此公式完成**迭代**次数

逻辑功能

1. 用时序逻辑直接如公式（1-1），**资源**：一个乘法器，一个加法，2个移位
2. 确定公式的有效数据输入区间（保证迭代次数）--功能是完成输入0-199个序列的输入
   + 开始
     + in_shake**有效的下个周期**
   + 结束
     + 完成第（200）个迭代周期处
3. 计算有效工作区间的迭代次数
   + 有效工作区间有效的周期，进行iter_cnt计数
4. 输入和输出的握手
   + 输入握手：rdy：拉低条件：收到hanshake；拉高条件：1.初始化，2.完成数据发送握手
   + 输出握手：vld：拉高条件：完成迭代；拉低条件：out_shake有效
5. 将功能1，每个公式输出xn经过判断后存入chaos_buffer
   + $2^{15}$ 是中位数，大于等于就取1，小于取0：最高位第16位为1，就代表大于等于中位数

![image-20221127122440822](./混沌序列仿真图)

## 2 序列转化参数单元

$$\huge\theta=(vld\_seq*360)>>GAIN\_INDEX$$

$$\huge\theta_1=(vld\_seq(1:N/2)*360)>>GAIN\_INDEX/2$$

$$\huge\theta_2=(vld\_seq(1+N/2:N)*360)>>GAIN\_INDEX/2$$

$$\huge z_1=(vld\_seq(1:N/2)*4096*18)>>GAIN\_INDEX/2$$

$$\huge z_2=(vld\_seq(1+N/2:N)*4096*18)>>GAIN\_INDEX/2$$

$$\huge N=subcarries*OFDM\_symbols$$

六个随机数最后作为参数输入到矩阵生成单元中



## 3 矩阵生成单元

![image-20221125210912325](./s1s2)                                     （3-1)

$$\large S[n]=0.5*\{a_0s_0[(n-z_0)_N]+a_1s_1[(n-z_1)_N]\} n\in\{0,1...N-1\}$$				(3-2)

$$\huge a=[exp(i*\theta_1*\pi/180),exp(i*\theta_2*\pi/180)]$$(3-3)

构造$s_1,s_2$序列，如式子（3-1），序列0-（N-1），向量的第0个和第N/2个是有数值的；数值大小由$\theta$决定的

1. $s_1,s_2$按照式子（3-1）生成
2. 根据式子（3-3）求出$a_0,a_1$
3. 根据式子3-2得出，$S[z_0],S[z_1],S[z_0+N/2],S[z_1+N/2]$这四个点有值，其余均为0；此为第一列向量
4. propm_mat矩阵根据第一列向量，一次循环生成循环正交预编码矩阵



# 4 扰乱效果

![image-20221126132003199](./星座图)
